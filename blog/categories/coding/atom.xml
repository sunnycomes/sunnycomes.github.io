<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coding | I/O View]]></title>
  <link href="http://www.iovi.com/blog/categories/coding/atom.xml" rel="self"/>
  <link href="http://www.iovi.com/"/>
  <updated>2014-01-01T11:49:09+08:00</updated>
  <id>http://www.iovi.com/</id>
  <author>
    <name><![CDATA[Sunny]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Performance Tuning Tips]]></title>
    <link href="http://www.iovi.com/blog/2013/11/11/java-performance-tunning-tips/"/>
    <updated>2013-11-11T20:59:44+08:00</updated>
    <id>http://www.iovi.com/blog/2013/11/11/java-performance-tunning-tips</id>
    <content type="html"><![CDATA[<p>The first version is completed on 2013.11.10 21:55, the main content is from <a href="http://www.exforsys.com/tutorials/j2ee/performance-tuning-of-java-applications.html">here</a>, thanks to the origin author.</p>

<p>Ever since the first version of Java Technology hit the streets, performance has been an important issue for Java developers. Java has improved dramatically and continually but, performance tuning is very essential to get the best results, especially when we think of J2EE applications.</p>

<!-- more -->


<h2>Introduction:</h2>

<p>Java Performance Tuning (abbreviated as JPT), 2nd edition provides a comprehensive guide to eliminate all the types of performance problems. By considering real-life examples JPT shows how to get rid off all the types of performances problems. For example JPT shows tricks such as how to minimize object creation and replacing strings with arrays can really pay off in improving code performance.</p>

<p>Few of important fundamentals and guidelines included in Java Performance Tuning are:</p>

<ul>
<li>Tuning tips for object creation.</li>
<li>Tuning in JDBC.</li>
<li>Web services performance tips.</li>
<li>Tuning in EJB.</li>
<li>Tuning in J2EE.</li>
<li>Tuning in JMS.</li>
<li>Tuning in RMI.</li>
</ul>


<p>Guidelines for tuning java code without destroying program&rsquo;s skeleton is efficiently presented in second edition of Java Performance Tuning. It includes how to use threads effectively, how to optimize the use of strings, minimizing the creation of objects in program, avoiding bottleneck operation by including all the important fundamentals of Software Engineering to re-pioneer the code, issues of speed of Servlets and JSPs etc. That provides very crucial guidelines in performance tuning for java developers.</p>

<h2>Tuning Tips for Object Creation:</h2>

<p>Object Creation is one of the most basic and essential thing while developing a Java Application, as such; object defines the physical reality of class. Pay proper attention while declaring class' methods and variables because careless work carried out at this stage, can cost you in terms of speed and performance because variables and methods unwontedly declared and initialize can create overhead in overall speed. Object should always be created early when there is spare time in the application, object once created should be in hold position until it is required. Care should be taken while defining methods that can accept the reusable objects to be filled with the data rather than methods that return objects holding that data, immutable objects can also be used here. Object should be created only when class logically needs. Constructor of class should always be simple. Methods that alter objects directly should always be preferred. Use classes that handle primitive data types rather than wrapping the primitive data types.</p>

<h2>Performance Tuning in JDBC:</h2>

<p>Java Database Connectivity (JDBC) is mainly used in most of the Java application. To keep trace on performance tuning in JDBC becomes very crucial and prime issue when Java developer realizes that most of the processing time should not be wasted behind data processing over the network. For more details, check out  <a href="/blog/2013/10/31/basic-practical-usage-of-jdbc-api/">here</a></p>

<p>Here are few of the tuning tips for JDBC that can improve the over all performance in Java application.</p>

<ul>
<li>SQL statements should be tuned to minimize the data that is return from the database.</li>
<li>Use of prepared statements and parameterized SQL statements can speed up the over all process in data processing.</li>
<li>Transaction conflicts should always be avoided.</li>
<li>Usage of stored procedures, connection pooling, selection of fastest JDBC driver should be encouraged.</li>
<li>Any of the open resources that is not in use in Java application can keep processor engaged unwontedly, any of the resource that is open and not required to perform any of database activity should be closed like Connections, Statements, ResultSet etc.</li>
</ul>


<h2>Web Services performance tips:</h2>

<p>Because of Java&rsquo;s outstanding performance in web services there are few of the performance tips that are to be considered while developing a web service application. Here are few of the tips given for improving the web services performance.</p>

<ul>
<li>Avoid using XML messaging, this helps to achieve fine-grained RPC.</li>
<li>Frequency of the messaging should be taken into consideration with the replication of the data as necessary.</li>
<li>Always try to retrieve data during off-hours this helps in course gained transactions.</li>
<li>Overall system performance should never be neglected and optimized until we know where the bottlenecks are present.</li>
<li>Asynchronous messaging model should always be taken into account when transport is slow or / and unreliable, or when processing is complex and long running.</li>
</ul>


<h2>Tips for Quality of services for Web Services</h2>

<p>The main requirements in quality of service for web services are:</p>

<ul>
<li>Availability and accessibility.</li>
<li>Integrity and reliability. This ensures that weather program will crash or not while it is running, if so, how often can it crash.</li>
<li>Number of simultaneous request that can be made to application by the user i.e. &ldquo;throughput&rdquo; and what will be the response time to process this request by application i.e. &ldquo;latency&rdquo;.</li>
<li>Security issues.</li>
<li>HTTP is a best-effort delivery service as far as web services issue is concerned. The main reason behind this is that request could simply be dropped. Messaging in web services should always be Asynchronous because Asynchronous messaging can improve throughput no matter at the cost of latency.</li>
<li>DOM based parsers are slower than SAX based ones.</li>
<li>Requests results should be cached whenever it is possible.</li>
<li>Extreme care should be taken to make sure that resources are not locked for long periods of time to avoid serious scalability problems.</li>
</ul>


<p>Other factor that affects web service performance are:</p>

<ul>
<li>Response time of web server.</li>
<li>Availability of web server.</li>
<li>Execution time of web application.</li>
<li>Backend database.</li>
<li>Scaling web services Tips</li>
</ul>


<p>Use of faster communication protocol, like plain socket, should always be preferred. Whenever there is requirement of sending large number of documents over the network, basic load-balancing scheme should be achieved, all the documents to be sent should have different URL hosts i.e. binding addresses. For scalability of server better and speedy hardware should be preferred though there is limitation of scalability of server,  that most application performance does not scale linearly with increases in the hardware power. Most of the times in web related services cluster of more than one server is used.</p>

<h2>Performance Tuning tips for EJB:</h2>

<p>While developing an EJB application if EJB services for an object is not required than plain Java object should be replaced in place of EJB object. Multiple remote method calls should be changed into one remote method call with all the data combined into a parameter object to enhance the overall process. There should be proper tuning in EJB Server thread count; Use Stateless session beans pool size to minimize the creation and destruction of the beans. When multiple EJB remote calls have to be changed into one session bean remote call and several local calls(SessionFacade), wrap multiple entity beans in a session bean. Transactional time-out should be set previously. Use HttpSession object rather than Stateful session bean to maintain client state. Bulk updating should be used to reduce the overall database calls to fetch and retrieving the data. When dealing with large amounts of data such as searching large database JDBC should be directly used rather than using entity beans.</p>

<h2>J2EE Performance tuning tips:</h2>

<p>Here few of the important tuning tips for J2EE in points.</p>

<ul>
<li>Entity beans from session beans should always be accessed.</li>
<li>When you no longer need to use session call HttpSession.invalidate() to clean up a session.</li>
<li>Save resources by turning off automatic session creation using <code>&lt; % @page session="false" % &gt;</code> for web pages that don&rsquo;t require session tracking.</li>
<li>Use compile time directive <code>&lt; % @include file="copyleft.html" % &gt;</code> where possible.</li>
<li>Whenever beans are co-located in the same JVM, use local entity beans.</li>
<li>Proprietary stubs can be used for caching and batching data.</li>
<li>To generate unique primary keys dedicated remote object should be used.</li>
<li>Whenever possible use cache tagging.</li>
<li>User JDBC directly instead of using an entity bean only for data access.</li>
</ul>


<h2>Tuning tips for JMS:</h2>

<p>For developing an efficient JMS application transient variables should be used to reduce serialization overheads. For receiving messages asynchronously implement MessageListener. To avoid persistency overhead choose non-durable (NON_PERSISTENT) messages wherever appropriate. It is practically efficient to use <code>DUPS_OK_ACKNOWLEDGE AND AUTO_ACKNOWLEDGE</code> than <code>CLIENT_ACKNOWLEDGE</code> as far as issue of performance is concerned. Separate transactional sessions and non-transactional sessions for transactional and non-transactional messages should be used separately. Because of the fact that &ldquo;a higher redelivery delay and lower redelivery limit reduces the overhead&rdquo; remember to tune the destination parameters. Open java resources can claim for more system resources never forget to close all the resources whenever they are not in use. The last point to be kept while developing a JMS application is that consumer should always start before we start the producer so that the initial messages do not need to be queued up.</p>

<h2>RMI tuning performance tips:</h2>

<p>To improve the performance in RMI application always consider altering the Tcp WindowSize parameter. To measure the bandwidth of network netp erf should be used. By setting the properties sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval RMI garbage collection should be configured in a proper manner. Since sending the object over network may consume much of the time in a big application sending groups of objects together rather than one object at a time is advisable. To speed up the transfers, implement Externalize interface. To handle special cases such as singleton or reusable objects use special codes. To improve overall development quality never try to add the extra complications once the performance target have been met.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic Practical Usage of JDBC API]]></title>
    <link href="http://www.iovi.com/blog/2013/10/31/basic-practical-usage-of-jdbc-api/"/>
    <updated>2013-10-31T14:54:53+08:00</updated>
    <id>http://www.iovi.com/blog/2013/10/31/basic-practical-usage-of-jdbc-api</id>
    <content type="html"><![CDATA[<p>The 1st version is completed on 2013.10.22 20:38, the main content is from <strong><em><a href="http://alumnus.caltech.edu/~chamness/JDBC_Tuning.pdf">here</a></em></strong>.</p>

<p>The 2nd version is completed on 2013.11.22 21:18, the main content is from <strong><em><a href="http://www.precisejava.com/javaperf/j2ee/JDBC.htm">Best practices to improve performance in JDBC</a></em></strong>, this is a great article about JDBC tuning.</p>

<p>This post is dedicated to illustrate techniques for optimizing JDBC API-based calls from the Java platform. As a result of this presentation, you will:</p>

<ul>
<li>Design better JDBC implementations</li>
<li>Recognize potential performance bottlenecks</li>
<li>Reduce cost during development</li>
</ul>


<h2>Agenda</h2>

<ol>
<li><a href="#why">Why optimize?</a></li>
<li><a href="api_tech">Basic API techniques.</a></li>
<li><a href="design_tech">Basic Design Techniques.</a></li>
<li><a href="strategies">Design Strategies.</a></li>
</ol>


<h2><a name='why'></a>Why Optimize?</h2>

<ul>
<li>On average, a web request performs 4 database queries.</li>
<li>Experience has shown that database calls are typical performance bottleneck.</li>
<li>Bad JDBC can overwhelm the database.</li>
</ul>


<!-- more -->


<p><a name='api_tech'></a>##Basic API techniques</p>

<p><img src="/images/upload/most_versatile_most_optimized.png" alt="most_versatile_most_optimized" /></p>

<h3>SQL Statements</h3>

<ul>
<li>Most flexible</li>
<li>Least reliable</li>
<li>Must be recompiled in database for each use</li>
</ul>


<h4>PreparedStatement</h4>

<ul>
<li>Represents a precompiled SQL statement</li>
<li>Can be used to efficiently execute statement multiple times</li>
<li>Somewhat flexible - can create new ones as needed</li>
</ul>


<h3>CallableStatement</h3>

<ul>
<li>Used to execute SQL stored procedures. Use stored procedures when they can be created in a standard manner. Do watch out for DB specific SP definitions that can cause migration headaches.</li>
<li>Same syntax as PreparedStatement.</li>
<li>Least flexible.</li>
<li>Most optimized DB call.</li>
</ul>


<h3>Cache</h3>

<p>Keep data within client to reduce the number of round-trips to the database.<br/>
Lesson: The less JDBC the better.</p>

<h2><a name='design_tech'></a>Basic Design Techniques</h2>

<h3>Use Database Connection Pool</h3>

<ul>
<li>Necessity for any production system.</li>
<li>Don&rsquo;t use DriverManager.getConnection() often. JDBC connections can take 0.5 to 2 seconds to create.</li>
<li>Create Pool of Connections and reuse them.</li>
</ul>


<h3>Use multi-threading with Connection Pooling to address network latency</h3>

<p>Threads can issue queries over separate database connections. This improves performance to a point.</p>

<pre><code>Single-batch Transactions
    BEGIN TRANSACTION
        UPDATE TABLE1... 
        INSERT INTO TABLE2...
        DELETE TABLE3
    COMMIT
</code></pre>

<h3>Single-batch Transactions&mdash;-Significantly different effects!</h3>

<ul>
<li>DB obtains necessary locks on rows and tables, uses and releases them in one step</li>
<li>Depending on transaction type, separate statements and commits can result in more DB calls and hold DB locks longer</li>
</ul>


<h3>Don&rsquo;t have transaction span user input</h3>

<p>Application sends BEGIN TRAN and SQL, locking rows or tables for update
Application waits for user to press key before committing transaction</p>

<h4>Solution: Optimistic locking</h4>

<ol>
<li>Optimistic locking employs timestamps and triggers in queries and updates</li>
<li>Queries select data with timestamp value</li>
<li>Prepare a transaction based on that value, without locking data in a transaction</li>
<li>If that value changed, this update is invalid and you should query again</li>
</ol>


<h3>Smart Queries</h3>

<ul>
<li>Make queries as specific as possible,Select only required columns rather than using select * from Tablexyz.</li>
<li>Put more logic into SQL statements</li>
<li>DB are designed to use SQL efficiently</li>
<li>Proper use of SQL can avoid performance problems</li>
</ul>


<p>Smart Query Ex: get employees in ENG dept, Instead of:</p>

<pre><code>SELECT * FROM employees; 
SELECT * FROM dept;
</code></pre>

<p>(and joining on Java application side), <strong>use database join:</strong></p>

<pre><code>SELECT employees.* FROM employees E, dept D 
WHERE E.DEPTNO = D.DEPTNO AND D.DEPTTYPE = 'ENG';
</code></pre>

<p>Minimize ResultSet before crossing network
Many performance problems come from moving raw data around needlessly</p>

<h3>Smart Query Guidelines</h3>

<ul>
<li>Use DB for filtering</li>
<li>Use Java for business logic</li>
<li>DB does filtering very well</li>
<li>DB business logic is poor(At least very inconsistent between database vendors.)</li>
</ul>


<h3>Keep operational data set small as possible</h3>

<ul>
<li>Move non-current data to other tables and do joins for rarer historical queries</li>
<li>Otherwise, index and cluster so frequently used data is logically and physically localized</li>
</ul>


<h2><a name='strategies'></a>Optimization Stategies</h2>

<ol>
<li>Leverage the strengths of the DB</li>
<li>Use the full range of java.sql API</li>
<li>Design for Performance - Connection Pools, Multi-Threading, etc.</li>
<li>Always close Statement and ResultSet objects as soon as possible.</li>
<li>Write modular classes to handle database interaction specifics.</li>
<li>Work with DatabaseMetaData to get information about database functionality.(Not quite understand.)</li>
<li>Softcode database specific parameters with, for example, properties files.</li>
<li>Always catch AND handle database warnings and exceptions. Be sure to check for additional pending exceptions.</li>
<li>Test your code with debug statements to determine the time it takes to execute your query and so on to help in tuning your code. Also use query plan functionality if available.</li>
<li>Use proper ( and a single standard if possible ) formats, especially for dates.</li>
<li>Use proper data types for specific kind of data. For example, store birthdate as a date type rather than, say, varchar.</li>
</ol>


<h2>References:</h2>

<ul>
<li><a href="http://www.precisejava.com/javaperf/j2ee/JDBC.htm">Best practices to improve performance in JDBC</a>(I love this most.)</li>
<li><a href="http://www.tutorialspoint.com/jdbc/jdbc-driver-types.htm">Jdbc Driver Types</a></li>
<li><a href="https://access.redhat.com/site/documentation/en-US/JBoss_Enterprise_Data_Services/5/html/Data_Services_Client_Developer_Guide/chap-JDBC_Transactions.html">JDBC Transactions</a></li>
<li><a href="http://www-01.ibm.com/software/webservers/appserv/ws_bestpractices.pdf">WebSphere Application Server Development Best Practices for Performance and Scalability</a></li>
<li><a href="http://www.jguru.com/faq/view.jsp?EID=131579">What areas should I focus on for the best performance in a JDBC application?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
