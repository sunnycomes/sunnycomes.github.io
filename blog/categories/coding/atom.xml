<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coding | I/O Vision]]></title>
  <link href="http://www.iovi.com/blog/categories/coding/atom.xml" rel="self"/>
  <link href="http://www.iovi.com/"/>
  <updated>2014-01-01T23:01:46+08:00</updated>
  <id>http://www.iovi.com/</id>
  <author>
    <name><![CDATA[Sunny]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Performance Tuning Tips]]></title>
    <link href="http://www.iovi.com/blog/2013/11/11/java-performance-tunning-tips/"/>
    <updated>2013-11-11T20:59:44+08:00</updated>
    <id>http://www.iovi.com/blog/2013/11/11/java-performance-tunning-tips</id>
    <content type="html"><![CDATA[<p>The first version is completed on 2013.11.10 21:55, the main content is from <a href="http://www.exforsys.com/tutorials/j2ee/performance-tuning-of-java-applications.html">here</a>, thanks to the origin author.</p>

<p>Ever since the first version of Java Technology hit the streets, performance has been an important issue for Java developers. Java has improved dramatically and continually but, performance tuning is very essential to get the best results, especially when we think of J2EE applications.</p>

<!-- more -->


<h2>Introduction:</h2>

<p>Java Performance Tuning (abbreviated as JPT), 2nd edition provides a comprehensive guide to eliminate all the types of performance problems. By considering real-life examples JPT shows how to get rid off all the types of performances problems. For example JPT shows tricks such as how to minimize object creation and replacing strings with arrays can really pay off in improving code performance.</p>

<p>Few of important fundamentals and guidelines included in Java Performance Tuning are:</p>

<ul>
<li>Tuning tips for object creation.</li>
<li>Tuning in JDBC.</li>
<li>Web services performance tips.</li>
<li>Tuning in EJB.</li>
<li>Tuning in J2EE.</li>
<li>Tuning in JMS.</li>
<li>Tuning in RMI.</li>
</ul>


<p>Guidelines for tuning java code without destroying program&rsquo;s skeleton is efficiently presented in second edition of Java Performance Tuning. It includes how to use threads effectively, how to optimize the use of strings, minimizing the creation of objects in program, avoiding bottleneck operation by including all the important fundamentals of Software Engineering to re-pioneer the code, issues of speed of Servlets and JSPs etc. That provides very crucial guidelines in performance tuning for java developers.</p>

<h2>Tuning Tips for Object Creation:</h2>

<p>Object Creation is one of the most basic and essential thing while developing a Java Application, as such; object defines the physical reality of class. Pay proper attention while declaring class' methods and variables because careless work carried out at this stage, can cost you in terms of speed and performance because variables and methods unwontedly declared and initialize can create overhead in overall speed. Object should always be created early when there is spare time in the application, object once created should be in hold position until it is required. Care should be taken while defining methods that can accept the reusable objects to be filled with the data rather than methods that return objects holding that data, immutable objects can also be used here. Object should be created only when class logically needs. Constructor of class should always be simple. Methods that alter objects directly should always be preferred. Use classes that handle primitive data types rather than wrapping the primitive data types.</p>

<h2>Performance Tuning in JDBC:</h2>

<p>Java Database Connectivity (JDBC) is mainly used in most of the Java application. To keep trace on performance tuning in JDBC becomes very crucial and prime issue when Java developer realizes that most of the processing time should not be wasted behind data processing over the network. For more details, check out  <a href="/blog/2013/10/31/basic-practical-usage-of-jdbc-api/">here</a></p>

<p>Here are few of the tuning tips for JDBC that can improve the over all performance in Java application.</p>

<ul>
<li>SQL statements should be tuned to minimize the data that is return from the database.</li>
<li>Use of prepared statements and parameterized SQL statements can speed up the over all process in data processing.</li>
<li>Transaction conflicts should always be avoided.</li>
<li>Usage of stored procedures, connection pooling, selection of fastest JDBC driver should be encouraged.</li>
<li>Any of the open resources that is not in use in Java application can keep processor engaged unwontedly, any of the resource that is open and not required to perform any of database activity should be closed like Connections, Statements, ResultSet etc.</li>
</ul>


<h2>Web Services performance tips:</h2>

<p>Because of Java&rsquo;s outstanding performance in web services there are few of the performance tips that are to be considered while developing a web service application. Here are few of the tips given for improving the web services performance.</p>

<ul>
<li>Avoid using XML messaging, this helps to achieve fine-grained RPC.</li>
<li>Frequency of the messaging should be taken into consideration with the replication of the data as necessary.</li>
<li>Always try to retrieve data during off-hours this helps in course gained transactions.</li>
<li>Overall system performance should never be neglected and optimized until we know where the bottlenecks are present.</li>
<li>Asynchronous messaging model should always be taken into account when transport is slow or / and unreliable, or when processing is complex and long running.</li>
</ul>


<h2>Tips for Quality of services for Web Services</h2>

<p>The main requirements in quality of service for web services are:</p>

<ul>
<li>Availability and accessibility.</li>
<li>Integrity and reliability. This ensures that weather program will crash or not while it is running, if so, how often can it crash.</li>
<li>Number of simultaneous request that can be made to application by the user i.e. &ldquo;throughput&rdquo; and what will be the response time to process this request by application i.e. &ldquo;latency&rdquo;.</li>
<li>Security issues.</li>
<li>HTTP is a best-effort delivery service as far as web services issue is concerned. The main reason behind this is that request could simply be dropped. Messaging in web services should always be Asynchronous because Asynchronous messaging can improve throughput no matter at the cost of latency.</li>
<li>DOM based parsers are slower than SAX based ones.</li>
<li>Requests results should be cached whenever it is possible.</li>
<li>Extreme care should be taken to make sure that resources are not locked for long periods of time to avoid serious scalability problems.</li>
</ul>


<p>Other factor that affects web service performance are:</p>

<ul>
<li>Response time of web server.</li>
<li>Availability of web server.</li>
<li>Execution time of web application.</li>
<li>Backend database.</li>
<li>Scaling web services Tips</li>
</ul>


<p>Use of faster communication protocol, like plain socket, should always be preferred. Whenever there is requirement of sending large number of documents over the network, basic load-balancing scheme should be achieved, all the documents to be sent should have different URL hosts i.e. binding addresses. For scalability of server better and speedy hardware should be preferred though there is limitation of scalability of server,  that most application performance does not scale linearly with increases in the hardware power. Most of the times in web related services cluster of more than one server is used.</p>

<h2>Performance Tuning tips for EJB:</h2>

<p>While developing an EJB application if EJB services for an object is not required than plain Java object should be replaced in place of EJB object. Multiple remote method calls should be changed into one remote method call with all the data combined into a parameter object to enhance the overall process. There should be proper tuning in EJB Server thread count; Use Stateless session beans pool size to minimize the creation and destruction of the beans. When multiple EJB remote calls have to be changed into one session bean remote call and several local calls(SessionFacade), wrap multiple entity beans in a session bean. Transactional time-out should be set previously. Use HttpSession object rather than Stateful session bean to maintain client state. Bulk updating should be used to reduce the overall database calls to fetch and retrieving the data. When dealing with large amounts of data such as searching large database JDBC should be directly used rather than using entity beans.</p>

<h2>J2EE Performance tuning tips:</h2>

<p>Here few of the important tuning tips for J2EE in points.</p>

<ul>
<li>Entity beans from session beans should always be accessed.</li>
<li>When you no longer need to use session call HttpSession.invalidate() to clean up a session.</li>
<li>Save resources by turning off automatic session creation using <code>&lt; % @page session="false" % &gt;</code> for web pages that don&rsquo;t require session tracking.</li>
<li>Use compile time directive <code>&lt; % @include file="copyleft.html" % &gt;</code> where possible.</li>
<li>Whenever beans are co-located in the same JVM, use local entity beans.</li>
<li>Proprietary stubs can be used for caching and batching data.</li>
<li>To generate unique primary keys dedicated remote object should be used.</li>
<li>Whenever possible use cache tagging.</li>
<li>User JDBC directly instead of using an entity bean only for data access.</li>
</ul>


<h2>Tuning tips for JMS:</h2>

<p>For developing an efficient JMS application transient variables should be used to reduce serialization overheads. For receiving messages asynchronously implement MessageListener. To avoid persistency overhead choose non-durable (NON_PERSISTENT) messages wherever appropriate. It is practically efficient to use <code>DUPS_OK_ACKNOWLEDGE AND AUTO_ACKNOWLEDGE</code> than <code>CLIENT_ACKNOWLEDGE</code> as far as issue of performance is concerned. Separate transactional sessions and non-transactional sessions for transactional and non-transactional messages should be used separately. Because of the fact that &ldquo;a higher redelivery delay and lower redelivery limit reduces the overhead&rdquo; remember to tune the destination parameters. Open java resources can claim for more system resources never forget to close all the resources whenever they are not in use. The last point to be kept while developing a JMS application is that consumer should always start before we start the producer so that the initial messages do not need to be queued up.</p>

<h2>RMI tuning performance tips:</h2>

<p>To improve the performance in RMI application always consider altering the Tcp WindowSize parameter. To measure the bandwidth of network netp erf should be used. By setting the properties sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval RMI garbage collection should be configured in a proper manner. Since sending the object over network may consume much of the time in a big application sending groups of objects together rather than one object at a time is advisable. To speed up the transfers, implement Externalize interface. To handle special cases such as singleton or reusable objects use special codes. To improve overall development quality never try to add the extra complications once the performance target have been met.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices to Improve Performance in JDBC]]></title>
    <link href="http://www.iovi.com/blog/2013/10/31/best-practices-to-improve-performance-in-JDBC/"/>
    <updated>2013-10-31T14:54:53+08:00</updated>
    <id>http://www.iovi.com/blog/2013/10/31/best-practices-to-improve-performance-in-JDBC</id>
    <content type="html"><![CDATA[<p>The 1st version is completed on 2013.10.22 20:38, the main content is from <strong><em><a href="http://alumnus.caltech.edu/~chamness/JDBC_Tuning.pdf">Performance Tuning for the JDBC API</a></em></strong>.</p>

<p>The 2nd version is completed on 2013.11.22 21:18, which modified completely, the main content is from <strong><em><a href="http://www.precisejava.com/javaperf/j2ee/JDBC.htm">Best practices to improve performance in JDBC</a></em></strong>, this is a great article about JDBC tuning.</p>

<p>This post is dedicated to illustrate techniques for optimizing JDBC API-based calls from the Java platform. As a result of this presentation, you will:</p>

<ul>
<li>Design better JDBC implementations</li>
<li>Recognize potential performance bottlenecks</li>
<li>Reduce cost during development</li>
</ul>


<h2>Agenda</h2>

<ol>
<li><a href="#why">Why optimize?</a></li>
<li><a href="#steps">Basic Steps to Write a JDBC Program.</a>

<ol>
<li><a href="#driver">Choosing the right Driver</a></li>
<li><a href="#connection">Optimization with Connection</a></li>
<li><a href="#statement">Optimization with Statement</a></li>
<li><a href="#result_set">Optimization with ResultSet</a></li>
<li><a href="#sql_query">Optimization with SQL Query</a></li>
</ol>
</li>
<li><a href="#other_means">Other Means of Optimization.</a></li>
<li><a href="#key_points">Key Points</a></li>
</ol>


<h2><a name='why'></a>Why Optimize?</h2>

<ul>
<li>On average, a web request performs 4 database queries.</li>
<li>Experience has shown that database calls are typical performance bottleneck.</li>
<li>Bad JDBC can overwhelm the database.</li>
</ul>


<!-- more -->


<h2><a name="steps"></a>Basic Steps to Write a JDBC Program</h2>

<p>The following are the basic steps to write a JDBC program</p>

<ol>
<li>Import java.sql and javax.sql packages</li>
<li>Load JDBC driver</li>
<li>Establish connection to the database using Connection interface</li>
<li>Create a Statement by passing SQL query</li>
<li>Execute the Statement</li>
<li>Retrieve results by using ResultSet interface</li>
<li>Close Statement and Connection</li>
</ol>


<p>We will look at these areas one by one, what type of driver you need to load, how to use Connection interface in the best manner, how to use different Statement interfaces, how to process results using ResultSet and finally how to optimize SQL queries to improve JDBC performance.</p>

<h3><a name="driver"></a>Choosing the right Driver</h3>

<table>
<thead>
<tr>
<th align="center"><em>Type</em> </th>
<th align="center"> <em>Tier</em> </th>
<th align="center"> <em>Driver mechanism</em> </th>
<th align="center"> <em>Description</em></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1 </td>
<td align="center">2  </td>
<td align="center">JDBC-ODBC    </td>
<td align="center">This driver converts JDBC calls to ODBC calls through JDBC-ODBC Bridge driver which in turn converts to database calls. Client requires ODBC libraries.</td>
</tr>
<tr>
<td align="center">2 </td>
<td align="center">2  </td>
<td align="center">Native API &ndash; Partly &ndash; Java driver</td>
<td align="center">This driver converts JDBC calls to database specific native calls. Client requires database specific libraries.</td>
</tr>
<tr>
<td align="center">3 </td>
<td align="center">3  </td>
<td align="center">JDBC &ndash; Net -All Java driver</td>
<td align="center">This driver passes calls to proxy server through network protocol which in turn converts to database calls and passes through database specific protocol. Client doesn&rsquo;t require any driver.</td>
</tr>
<tr>
<td align="center">4 </td>
<td align="center">2  </td>
<td align="center">Native protocol &ndash; All &ndash; Java driver</td>
<td align="center">This driver directly calls database. Client doesn&rsquo;t require any driver.</td>
</tr>
</tbody>
</table>


<p>Type 3 &amp; 4 drivers are faster than other drivers because Type 3 gives facility for optimization techniques provided by application server such as connection pooling, caching, load balancing etc and Type 4 driver need not translate database calls to ODBC or native connectivity interface. Type 1 drivers are slow because they have to convert JDBC calls to ODBC through JDBC-ODBC Bridge driver initially and then ODBC Driver converts them into database specific calls. Type 2 drivers give average performance when compared to Type 3 &amp; 4 drivers because the database calls have to be converted into database specific calls. Type 2 drivers give better performance than Type 1 drivers.</p>

<h3><a name="connection"></a>Optimization with Connection</h3>

<p>We have different approaches to establish a connection with the database, the <strong>first</strong> type of approach is :</p>

<ol>
<li>DriverManager.getConnection(String url)</li>
<li>DriverManager.getConnection(String url, Properties props)</li>
<li>DriverManager.getConnection(String url, String user, String password)</li>
<li>Driver.connect(String url, Properties props)</li>
</ol>


<p>When you use this approach, you can pass database specific information to the database by passing properties using Properties object to improve performance. For example, when you use oracle database you can pass default number of rows that must be pre-fetched from the database server and the default batch value that triggers an execution request. Oracle has default value as 10 for both properties. By increasing the value of these properties, you can reduce the number of database calls which in turn improves performance. The following code snippet illustrates this approach.</p>

<pre><code>    java.util.Properties props = new java.util.Properties();
    props.put("user","scott");
    props.put("password","tiger");
    props.put("defaultRowPrefetch","30");
    props.put("defaultBatchValue","5");
    Connection con = DriverManger.getConnection("jdbc:oracle:thin:@hoststring", props);
</code></pre>

<p>You need to figure out appropriate values for above properties for better performance depending on application&rsquo;s requirement. Suppose, you want to set these properties for search facility, you can increase defaultRowPrefetch so that you can increase performance significantly.</p>

<p>The <strong>second</strong> type of approach is to get connection from DataSource. You can get the connection using javax.sql.DataSource interface. The advantage of getting connection from this approach is that the DataSource works with JNDI. The implementation of DataSource is done by vendor, for example you can find this feature in weblogic, websphere etc. The vendor simply creates DataSource implementation class and binds it to the JNDI tree. The following code shows how a vendor creates implementation class and binds it to JNDI tree.</p>

<pre><code>    DataSourceImpl dsi = new DataSourceImpl();
    dsi.setServerName("oracle8i");
    dsi.setDatabaseName("Demo");
    Context ctx = new InitialContext();
    ctx.bind("jdbc/demoDB", dsi);
</code></pre>

<p>This code registers the DataSourceImpl object to the JNDI tree, then the programmer can get the DataSource reference from JNDI tree without knowledge of the underlying technology.</p>

<pre><code>    Context ctx = new InitialContext();
    DataSource ds = (DataSource)ctx.lookup("jdbc/demoDB");
    Connection con = ds.getConnection();
</code></pre>

<p>By using this approach we can improve performance. Nearly all major vendor application servers like weblogic, webshpere implement the DataSource by taking connection from connection pool rather than a single connection every time. The application server creates connection pool by default. We will discuss the advantage of connection pool to improve performance in the next section.</p>

<h4>Use Connection Pool</h4>

<p>Creating a connection to the database server is expensive. It is even more expensive if the server is located on another machine. Connection pool contains a number of open database connections with minimum and maximum connections, that means the connection pool has open connections between minimum and maximum number that you specify. The pool expands and shrinks between minimum and maximum size depending on incremental capacity. You need to give minimum, maximum and incremental sizes as properties to the pool in order to maintain that functionality. You get the connection from the pool rather directly .For example, if you give properties like min, max and incremental sizes as 3, 10 and 1 then pool is created with size 3 initially and if it reaches it&rsquo;s capacity 3 and if a client requests a connection concurrently, it increments its capacity by 1 till it reaches 10 and later on it puts all its clients in a queue.</p>

<p>In general, transaction represents one unit of work or bunch of code in the program that executes in it&rsquo;s entirety or none at all. To be precise, it is all or no work. In JDBC, transaction is a set of one or more Statements that execute as a single unit.
java.sql.Connection interface provides some methods to control transaction they are</p>

<pre><code>    public interface Connection {
        boolean getAutoCommit();
        void        setAutoCommit(boolean autocommit);
        void        commit();
        void        rollback();
    }
</code></pre>

<h4>JDBC&rsquo;s default mechanism for transactions:</h4>

<p>By default in JDBC transaction starts and commits after each statement&rsquo;s  execution on a connection. That is the AutoCommit mode is true. Programmer need not write a commit() method explicitly after each statement.Obviously this default mechanism gives good facility for programmers if they want to execute a single statement. But it gives poor performance when multiple statements on a connection are to be executed because commit is issued after each statement by default, that in turn reduces performance by issuing unnecessary commits. The remedy is to flip it back to AutoCommit mode as false and issue commit() method after a set of statements execute, this is called as batch transaction. Use rollback() in catch block to rollback the transaction whenever an exception occurs in your program. The following code illustrates the batch transaction approach.This batch transaction gives good performance by reducing commit calls after each statement&rsquo;s execution.</p>

<h3>Choose optimal isolation level</h3>

<p>Isolation level represent how a database maintains data integrity against the problems like dirty reads, phantom reads and non-repeatable reads which can occur due to concurrent transactions. java.sql.Connection interface provides  methods and constants to avoid the above mentioned problems by setting different isolation levels.
public interface Connection {</p>

<pre><code>    public static final int  TRANSACTION_NONE                               = 0
    public static final int  TRANSACTION_READ_COMMITTED                 = 2
    public static final int  TRANSACTION_READ_UNCOMMITTED           = 1
    public static final int  TRANSACTION_REPEATABLE_READ            = 4
    public static final int  TRANSACTION_SERIALIZABLE                   = 8
    int          getTransactionIsolation();
    void        setTransactionIsolation(int isolationlevelconstant);
</code></pre>

<p>}</p>

<p>More details are covered in <a href="/blog/2013/10/11/optimal-isolation-level/">Optimal JDBC Transaction Isolation Level</a> and <a href="/blog/2013/10/21/optimistic-and-pessimistic-locking/">Optimistic and Pessimistic Locking</a></p>

<h3>Optimization with Statement</h3>

<p>Statement interface represents SQL query and execution and they provide number of methods and constants to work with queries. They also provide some methods to fine tune performance. Programmer may overlook these fine tuning methods that result in poor performance. The following are the tips to improve performance by using statement interfaces</p>

<ol>
<li>Choose the right Statement interface</li>
<li>Do batch update</li>
<li>Do batch retrieval using Statement</li>
<li>Close Statement when finished</li>
</ol>


<h4>1. Choose right Statement interface</h4>

<p>There are three types of Statement interfaces in JDBC to represent the SQL query and execute that query, they are Statement, PreparedStatement and CallableStatement.
Statement is used for static SQL statement with no input and output parameters, PreparedStatement is used for dynamic SQL statement with input parameters and CallableStatement is used for dynamic SQL satement with both input and output parameters, but PreparedStatement and CallableStatement can be used for static SQL statements as well. CallableStatement is mainly meant for stored procedures.</p>

<p>PreparedStatement gives better performance when compared to Statement because it is pre-parsed and pre-compiled by the database once for the first time and then onwards it reuses the parsed and compiled statement. Because of this feature, it significantly improves performance when a statement executes repeatedly, It reduces the overload incurred by parsing and compiling.</p>

<p>CallableStatement gives better performance when compared to PreparedStatement and Statement when there is a requirement for single request to process multiple complex statements. It parses and stores the stored procedures in the database and does all the work at database itself that in turn improves performance. But we loose java portability and we have to depend up on database specific stored procedures.</p>

<h4>2. Do batch update</h4>

<p>You can send multiple queries to the database at a time using batch update feature of statement objects this reduces the number of JDBC calls and improves performance. Here is an example of how you can do batch update,</p>

<pre><code>statement.addBatch( "sql query1");
statement.addBatch(" sql query2");
statement.addBatch(" sql query3");
statement.executeBatch();
</code></pre>

<p><strong>All</strong> three types of statements have these methods to do batch update.</p>

<h4>3. Do batch retrieval using Statement</h4>

<p>You can get the default number of rows that is provided by the driver. You can improve performance by increasing number of rows to be fetched at a time from database using <code>setFetchSize()</code> method of the statement object.Initially find the default size by using <code>Statement.getFetchSize();</code>   and then set the size as per your requirement <code>Statement.setFetchSize(30);</code>Here it retrieves 30 rows at a time for all result sets of this statement.</p>

<h4>4. Close Statement when finished</h4>

<p>Close statement object as soon as you finish working with that, it explicitly gives a chance to garbage collector to recollect memory as early as possible which in turn effects performance. Statement.close();</p>

<h3>Optimization with ResultSet</h3>

<p>ResultSet interface represents data that contains the results of executing an SQL Query and it provides a number of methods and constants to work with that data. It also provides methods to fine tune retrieval of data to improve performance. The following are the fine tuning tips to improve performance by using ResultSet interface.
1. Do batch retrieval using ResultSet
2. Set up proper direction for processing the rows
3. Use proper get methods
4. Close ResultSet when finished</p>

<h4>1. Do batch retrieval using ResultSet</h4>

<p>ResultSet interface also provides batch retrieval facility like Statement as mentioned above. It overrides the Statement behaviour. Initially find the default size by using
<code>ResultSet.getFetchSize();</code> and then set the size as per requirement <code>ResultSet.setFetchSize(50);</code> This feature significantly improves performance when you are dealing with retrieval of large number of rows like search functionality.</p>

<h4>2. Setup proper direction of processing rows</h4>

<p>ResultSet has the capability of setting the direction in which you want to process the results, it has three constants for this purpose, they are <code>FETCH_FORWARD</code>, <code>FETCH_REVERSE</code>, <code>FETCH_UNKNOWN</code>. Initially find the direction by using <code>ResultSet.getFetchDirection();</code> and then set the direction accordingly <code>ResultSet.setFetchDirection(FETCH_REVERSE);</code></p>

<h4>3. Use proper <code>getxxx()</code> methods</h4>

<p>ResultSet interface provides lot of getxxx() methods to get and convert database data types to java data types and is flexibile in converting non feasible data types. For example, <code>getString(String columnName)</code> returns java String object. <code>columnName</code> is recommended to be a <code>VARCHAR</code> or <code>CHAR</code> type of database but it can also be a <code>NUMERIC</code>, <code>DATE</code> etc.If you give non recommended parameters, it needs to cast it to proper java data type that is  expensive. For example consider that  you select  a product&rsquo;s id from huge database which returns millions of records from search functionality, it needs to convert all these records that is very expensive.
So always use proper getxxx() methods according to JDBC recommendations.</p>

<h4>4. Close ResultSet when finished</h4>

<p>Close ResultSet object as soon as you finish working with ResultSet object even though Statement object closes the ResultSet object implicitly when it closes, closing ResultSet explicitly gives chance to garbage collector to recollect memory as early as possible because ResultSet object may occupy lot of memory depending on query.
<code>ResultSet.close();</code></p>

<h3>Optimization with SQL Query</h3>

<p>This is one of the area where programmers generally make a mistake. If you give a query like</p>

<pre><code>Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("select * from employee where name=RR");
</code></pre>

<p>The returned result set contains all the columns data. you may not need all the column data and want only salary for RR.
The better query is <code>"select salary from employee where name=RR"</code>
It returns the required data  and reduces unnecessary data retrieval. Make your query specific.</p>

<h3>Cache the read-only and read-mostly data</h3>

<p>Every database schema generally has read-only and read-mostly tables. These tables are called as lookup tables. Read-only tables contain static data that never changes in its life time. Read-mostly tables contain semi dynamic data that changes often. There will not be any sort of writing operations in these tables.
If an application reads data from these tables for every client request, then it is redundant, unnecessary and expensive. The solution for this problem is to cache the read-only table data by reading the data from that table once and caching the read-mostly table data by reading and refreshing with time limit. This solution improves performance significantly. See the following link for source code of such <a href="http://www.javaworld.com/javaworld/jw-07-2001/jw-0720-cache.html">caching mechanism</a>.</p>

<p>You can tweak this code as per application requirement. For read-only data, you need not refresh data in its life time. For read-mostly data, you need to refresh the data with time limit. It is better to set this refreshing time limit in properties file so that it can be changed at any time.</p>

<h4>Fetch small amount of data iteratively instead of fetching whole data at once</h4>

<p>Applications generally require to retrieve huge data from the database using JDBC in operations  like searching data. If the client request for a search, the application might return the whole result set at once. This process takes lot of time and has an impact on performance. The solution for the problem is</p>

<ol>
<li>Cache the search data at the server-side and return the data iteratively to the client. For example, the search returns 1000 records, return data to the client in 10 iterations where each iteration has 100 records.</li>
<li>Use Stored procedures to return data iteratively. This does not use server-side caching rather server-side application uses Stored procedures to return small amount of data iteratively.</li>
</ol>


<p>Out of these solutions the second solution gives better performance because it need not keep the data in the cache (in-memory). The first procedure is useful when the total amount of data to be returned is not huge.</p>

<h2>Key Points</h2>

<ul>
<li>Use Type two driver for two tiered applications to communicate from java client to database that gives better performance than Type1 driver.</li>
<li>Use Type four driver for applet to database communication that is two tiered applications and three tiered applications when compared to other drivers.</li>
<li>Use Type one driver if you don&rsquo;t have a driver for your database. This is a rare situation because all major databases support drivers or you will get a driver from third party vendors.</li>
<li>Use Type three driver to communicate between client and proxy server ( weblogic, websphere etc) for three tiered applications that gives better performance when compared to Type 1&amp;2 drivers.</li>
<li>Pass database specific properties like defaultPrefetch if your database supports any of them.</li>
<li>Get database connection from connection pool rather than getting it directly</li>
<li>Use batch transactions.</li>
<li>Choose right isolation level as per your requirement. TRANSACTION_READ_UNCOMMITED gives best performance for concurrent transaction based applications. TRANSACTION_NONE gives best performance for non-concurrent transaction based applications.
*Your database server may not support all isolation levels, be aware of your database server features.</li>
<li>Use PreparedStatement when you execute the same statement more than once.</li>
<li>Use CallableStatement when you want result from multiple and complex statements for a single request.</li>
<li>Use batch update facility available in Statements.</li>
<li>Use batch retrieval facility available in Statements or ResultSet.</li>
<li>Set up proper direction for processing rows.</li>
<li>Use proper getXXX() methods.</li>
<li>Close ResultSet, Statement and Connection whenever you finish your work with them.</li>
<li>Write precise SQL queries.</li>
<li>Cache read-only and read-mostly tables data.</li>
<li>Fetch small amount of data iteratively rather than whole data at once when retrieving large amount of data like searching database etc.</li>
</ul>


<h2>References:</h2>

<ul>
<li><a href="http://www.precisejava.com/javaperf/j2ee/JDBC.htm">Best practices to improve performance in JDBC</a>(I love this most.)</li>
<li><a href="http://www.tutorialspoint.com/jdbc/jdbc-driver-types.htm">Jdbc Driver Types</a></li>
<li><a href="https://access.redhat.com/site/documentation/en-US/JBoss_Enterprise_Data_Services/5/html/Data_Services_Client_Developer_Guide/chap-JDBC_Transactions.html">JDBC Transactions</a></li>
<li><a href="http://www-01.ibm.com/software/webservers/appserv/ws_bestpractices.pdf">WebSphere Application Server Development Best Practices for Performance and Scalability</a></li>
<li><a href="http://www.jguru.com/faq/view.jsp?EID=131579">What areas should I focus on for the best performance in a JDBC application?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimistic and Pessimistic Locking]]></title>
    <link href="http://www.iovi.com/blog/2013/10/21/optimistic-and-pessimistic-locking/"/>
    <updated>2013-10-21T21:40:48+08:00</updated>
    <id>http://www.iovi.com/blog/2013/10/21/optimistic-and-pessimistic-locking</id>
    <content type="html"><![CDATA[<h2>Locking Introduction</h2>

<p>This article talks about serveral ways of doing locking. It starts with concurrency problems and then discusses about 2 ways of doing optimistic locking. As optimistic locking does not solve the concurrency issues from roots, it introduces pessimistic locking. It then moves ahead to explain how isolation levels can help us implement pessimistic locking. Each isolation level is explained with sample demonstration to make concepts clearer.</p>

<h2>Why do we need locking?</h2>

<p>In multi-user environment it&rsquo;s possible that multiple users can update the same record at the same time causing confusion between users. This issue is termed as concurrency.</p>

<h2>How can we solve concurrency problems?</h2>

<p>Concurrency problems can be solved by implementing proper &ldquo;Locking strategy&rdquo;. Locks prevent action on a resource to be performed when some other resource is already performing some action on it.</p>

<h2>Optimistic Locking</h2>

<p>As the name suggests &ldquo;optimistic&rdquo; it assumes that multiple transaction will work without affecting each other. In other words no locks are enforced while doing optimistic locking. The transaction just verifies that no other transaction has modified the data. In case of modification the transaction is rolled back.</p>

<h3>How does optimistic lock work?</h3>

<p>You can implement optimistic locking by numerous ways but the fundamental to implement optimistic locking remains same. It&rsquo;s a 4 step process as shown below:</p>

<ol>
<li>Record the current timestamp.</li>
<li>Start changing the values.</li>
<li>Before updating check whether anyone else has changed the values by checking the old time stamp and new time stamp or the old value and the current value in database.</li>
<li>If it&rsquo;s not equal rollbacks or else commit.</li>
</ol>


<p><img src="/images/upload/optimistic_locking.jpg" alt="optimistic_locking" /></p>

<pre><code>update tbl_items set itemname='itemname' where CurrentTimestamp='OldTimeStamp'

update tbl_items set itemname=@itemname where itemname=@OldItemNameValue
</code></pre>

<h2>Pessimistic Locking</h2>

<p>But it looks like by using optimistic locking concurrency problems are not really solved?Yes, you said right. By using optimistic locking you only detect the concurrency problem. To solve concurrency issues from the roots itself we need to use pessimistic locking. Optimistic is like prevention while pessimistic locking is actually the cure.
Pessimistic locking assumes that concurrency/collision issues will happen so a lock is placed on the records and then data is updated.</p>

<h3>How can we do pessimistic locking?</h3>

<p>We can do pessimistic locking by specifying &ldquo;IsolationLevel&rdquo; in SQL Server stored procedures, ADO.NET level or by using transaction scope object, in java the JDBC Connection.</p>

<h3>What kind of locks can be acquired by using pessimistic locking?</h3>

<p>There are 4 kinds of locks you can acquire Shared, Exclusive, Update and intent. The first two are actual locks while the other two are hybrid locks and marker. Correspondingly, in SQL there are 4 kinds of transaction isolation level, below is a simple table which shows when to use them and what locks they put.</p>

<table>
<thead>
<tr>
<th align="center">Isolation Level      </th>
<th align="center">  Read                    </th>
<th align="center">Update     </th>
<th align="center">Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Read Uncommitted     </td>
<td align="center">  Reads data which is yet not committed.  </td>
<td align="center">Allowed    </td>
<td align="center">Allowed</td>
</tr>
<tr>
<td align="center">Read Committed ( Default)</td>
<td align="center">  Reads data which is committed.      </td>
<td align="center">Allowed    </td>
<td align="center">Allowed</td>
</tr>
<tr>
<td align="center">Repeatable Read      </td>
<td align="center">  Reads data which is committed.      </td>
<td align="center">Not Allowed    </td>
<td align="center">Allowed</td>
</tr>
<tr>
<td align="center">Serializable         </td>
<td align="center">  Reads data which is committed.      </td>
<td align="center">Not Allowed    </td>
<td align="center">Not Allowed</td>
</tr>
</tbody>
</table>


<p>More details are covered in this post<a href="/blog/2013/10/11/optimal-isolation-level/">Optimal Isolation Level</a>;</p>

<h2>References:</h2>

<p><a href="http://www.codeproject.com/Articles/114262/6-ways-of-doing-locking-in-NET-Pessimistic-and-opt#Solution%20number%202:-%20Use%20timestamp%20data%20type">6 ways of doing locking in .NET (Pessimistic and optimistic)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimal JDBC Transaction Isolation Level]]></title>
    <link href="http://www.iovi.com/blog/2013/10/11/optimal-isolation-level/"/>
    <updated>2013-10-11T16:09:47+08:00</updated>
    <id>http://www.iovi.com/blog/2013/10/11/optimal-isolation-level</id>
    <content type="html"><![CDATA[<h2>Choose optimal isolation level</h2>

<p>Isolation level represent how a database maintains data integrity against the problems like dirty reads, phantom reads and non-repeatable reads which can occur due to concurrent transactions. java.sql.Connection interface provides  methods and constants to avoid the above mentioned problems by setting different isolation levels.</p>

<pre><code>public interface Connection {
    public static final int  TRANSACTION_NONE                 = 0
    public static final int  TRANSACTION_READ_COMMITTED       = 2
    public static final int  TRANSACTION_READ_UNCOMMITTED     = 1
    public static final int  TRANSACTION_REPEATABLE_READ      = 4
    public static final int  TRANSACTION_SERIALIZABLE         = 8
    int    getTransactionIsolation();
    void   setTransactionIsolation(int isolationlevelconstant);
}
</code></pre>

<p>You can get the existing isolation level with getTransactionIsolation() method and set the isolation level with setTransactionIsolation(int isolationlevelconstant) by passing above constants to this method.
The following table describes isolation level against the problem that it prevents :</p>

<table>
<thead>
<tr>
<th align="center">Transaction Level       </th>
<th align="center"> Dirty reads   </th>
<th align="center">Non  Repeatable reads  </th>
<th align="center"> Phantom reads </th>
<th align="center">Performance impact</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">TRANSACTION_NONE        </td>
<td align="center"> N/A       </td>
<td align="center"> N/A           </td>
<td align="center"> N/A       </td>
<td align="center"> FASTEST</td>
</tr>
<tr>
<td align="center">TRANSACTION_READ_UNCOMMITED </td>
<td align="center"> YES       </td>
<td align="center"> YES           </td>
<td align="center"> YES       </td>
<td align="center"> FASTEST</td>
</tr>
<tr>
<td align="center">TRANSACTION_READ_COMMITED   </td>
<td align="center"> NO        </td>
<td align="center"> YES           </td>
<td align="center"> YES       </td>
<td align="center"> FAST</td>
</tr>
<tr>
<td align="center">TRANSACTION_REPEATABLE_READ </td>
<td align="center"> NO        </td>
<td align="center"> NO            </td>
<td align="center"> YES       </td>
<td align="center"> MEDIUM</td>
</tr>
<tr>
<td align="center">TRANSACTION_SERIALIZABLE    </td>
<td align="center"> NO        </td>
<td align="center"> NO            </td>
<td align="center"> NO        </td>
<td align="center"> SLOW</td>
</tr>
</tbody>
</table>


<br/>


<ul>
<li>YES means that the Isolation level does not prevent the problem</li>
<li>NO means that the Isolation level prevents the problem</li>
</ul>


<p>By setting isolation levels, you are having an impact on the performance as mentioned in the above table. Database use read and write locks to control above isolation levels. Let us have a look at each of these problems and then look at the impact on the performance.</p>

<h3>Dirty read problem :</h3>

<p>The following figure illustrates Dirty read problem  :</p>

<p> <img src="/images/upload/dirty_read.gif" alt="dirty_read" /></p>

<pre><code>Step 1:    Database row has PRODUCT = A001 and PRICE = 10
Step 2:    Connection1 starts  Transaction1 (T1) .
Step 3:    Connection2 starts  Transaction2 (T2) .
Step 4:    T1 updates PRICE =20 for PRODUCT = A001
Step 5:    Database has now PRICE = 20 for PRODUCT = A001
Step 6:    T2 reads PRICE = 20 for PRODUCT = A001
Step 7:    T2 commits transaction
Step 8:    T1 rollbacks the transaction because of some problem
</code></pre>

<p>The problem is that T2 gets wrong PRICE=20 for PRODUCT = A001 instead of 10 because of uncommitted read.Obviously it is very dangerous in critical transactions if you read inconsistent data. If you  are sure about not accessing data concurrently  then you can allow this problem by setting TRANSACTION_READ_UNCOMMITED or TRANSACTION_NONE that in turn improves performance otherwise you have to use TRANSACTION_READ_COMMITED to avoid this problem.</p>

<h3>Unrepeatable read problem :</h3>

<p>The following figure illustrates Unrepeatable read problem  :</p>

<p><img src="/images/upload/unrepeatable_read.gif" alt="unrepeatable_read" /></p>

<pre><code>Step 1:    Database row has PRODUCT = A001 and PRICE = 10
Step 2:    Connection1 starts  Transaction1 (T1) .
Step 3:    Connection2 starts  Transaction2 (T2) .
Step 4:    T1 reads PRICE =10 for PRODUCT = A001
Step 5:    T2 updates PRICE = 20 for PRODUCT = A001
Step 6:    T2 commits transaction
Step 7:    Database row has PRODUCT = A001 and PRICE = 20
Step 8:    T1 reads PRICE = 20 for PRODUCT = A001
Step 9:    T1 commits transaction
</code></pre>

<p>Here the problem is that Transaction1 reads 10 first time and reads 20 second time but it is supposed to be 10 always whenever it reads a record in that transaction. You can control this problem by setting isolation level as TRANSACTION_REPEATABLE_READ(setting for which one? Of course both).</p>

<h3>Phantom read problem :</h3>

<p>The following figure illustrates Phantom read problem  :</p>

<p><img src="/images/upload/phantom_read.gif" alt="phantom_read" /></p>

<pre><code>Step 1:    Database has a row PRODUCT = A001 and COMPANY_ID = 10
Step 2:    Connection1 starts  Transaction1 (T1) .
Step 3:    Connection2 starts  Transaction2 (T2) .
Step 4:    T1 selects a row with a condition SELECT PRODUCT WHERE COMPANY_ID = 10
Step 5:    T2 inserts a row with a condition INSERT PRODUCT=A002  WHERE COMPANY_ID= 10
Step 6:    T2 commits transaction
Step 7:    Database has 2 rows with that condition
Step 8:    T1 select again with a condition SELECT PRODUCT WHERE COMPANY_ID=10 and gets 2 rows instead of 1 row
Step 9:    T1 commits transaction
</code></pre>

<p>Here the problem is that T1 gets 2 rows instead of 1 row up on selecting the same condition second time. You can control this problem by setting isolation level as <code>TRANSACTION_SERIALIZABLE</code></p>

<h2>Choosing a right isolation level for your program:</h2>

<p>Choosing a right isolation level for your program depends upon your application&rsquo;s requirement. In single application itself the requirement generally changes, suppose if you write a program for searching a product catalog from your database then you can easily choose <code>TRANSACTION_READ_UNCOMMITED</code> because you need not worry about the problems that are mentioned above, some other program can insert records at the same time, you don&rsquo;t have to bother much about that insertion. Obviously this improves performance significantly.</p>

<p>If you write a critical program like bank or stocks analysis program where you want to control all of the above mentioned problems, you can choose TRANSACTION_SERIALIZABLE for maximum safety. Here it is the tradeoff between the safety and performance. Ultimately we need safety here.
If you don&rsquo;t have to deal with concurrent transactions your application, then the best choice is <code>TRANSACTION_NONE</code> to improve performance.
Other two isolation levels need good understanding of your requirement. If your application needs only committed records, then <code>TRANSACTION_READ_COMMITED</code> isolation is the good choice. If your application needs to read a row exclusively till you  finish your work, then <code>TRANSACTION_REPEATABLE_READ</code> is the best choice.
Note: Be aware of your database server&rsquo;s support for these isolation levels. Database servers may not support all of these isolation levels. Oracle server supports only two isolation levels, <code>TRANSACTION_READ_COMMITED</code> and <code>TRANSACTION_SERIALIZABLE</code> isolation level, default isolation level is <code>TRANSACTION_READ_COMMITED</code>.</p>

<h2>References</h2>

<ul>
<li><a href="http://www.precisejava.com/javaperf/j2ee/JDBC.htm#JDBC102">Best practices to improve performance in JDBC</a></li>
<li><a href="http://www.codeproject.com/Articles/114262/6-ways-of-doing-locking-in-NET-Pessimistic-and-opt#Solution%20number%202:-%20Use%20timestamp%20data%20type">6 ways of doing locking in .NET (Pessimistic and optimistic)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
